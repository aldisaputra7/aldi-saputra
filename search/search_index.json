{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Selamat Datang di Halaman Tugas Penambangan Data Nama : Aldi Saputra Nim : 180411100087 Kelas : Penambangan Data 5D Dosen Pengampu : Mula`ab.S.SI.,M.Kom Prodi : Teknik Informatika Alamat : Jalan Brawijaya 38 Surabaya","title":"Data Mahasiswa"},{"location":"#selamat-datang-di-halaman-tugas-penambangan-data","text":"Nama : Aldi Saputra Nim : 180411100087 Kelas : Penambangan Data 5D Dosen Pengampu : Mula`ab.S.SI.,M.Kom Prodi : Teknik Informatika Alamat : Jalan Brawijaya 38 Surabaya","title":"Selamat Datang di Halaman Tugas Penambangan Data"},{"location":"Deskripsi/","text":"Rata-rata rata-rata adalah suatu bilangan yang mewakili sekumpulan data Rumus Rata-rata: $$ \\begin{align }\\bar{X}=\\frac{\\sum X}{N}\\end{align } $$ Median Median atau nilai tengah adalah salah satu ukuran pemusatan data, yaitu, jika segugus data diurutkan dari yang terkecil sampai yang terbesar atau yang terbesar sampai yang terkecil, nilai pengamatan yang tepat di tengah-tengah bila jumlah datanya ganjil, atau rata-rata kedua pengamatan yang di tengah bila banyaknya pengamatan genap. Rumus Median: $$ \\begin{align }\\left { \\frac{n+1}{2} \\right }\\end{align } $$ Modus Modus adalah data yang paling sering muncul, atau data yang mempunyai frekuensi terbesar. Rumus: Nilai yang paling banyak muncul Standard deviasi Standar deviasi adalah nilai statistik yang digunakan untuk menentukan bagaimana sebaran data dalam sampel, dan seberapa dekat titik data individu ke mean \u2013 atau rata-rata \u2013 nilai sampel. Rumus: $$ \\begin{align }\\sigma = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}}\\left ( x_{i} -\\mu \\right )^{2}\\end{align } $$ Varian varian adalah ukuran seberapa jauh sebuah kumpulan bilangan tersebar. Varians nol mengindikasikan bahwa semua nilai sama. Varians selalu bernilai non-negatif: varians yang rendah mengindikasikan bahwa titik data condong sangat dekat dengan nilai rerata (nilai ekspektasi) dan antara satu sama lainnya, sementara varians yang tinggi mengindikasikan bahwa titik data sangat tersebar disekitar rerata dan dari satu sama lainnya. rumus: $$ \\begin{align }s^{2}\\frac{n\\sum_{n}^{i=1}x_{i}^{2}-\\left ( \\sum_{i=1}^{n}x_{1} \\right )^{2}}{n\\left ( n-1 \\right )}\\end{align } $$ Di aplikasikan pada python Kita membutuhkan Jupyter notebook ,library python , dan untuk menentukan datanya kita menggunakan excel ini adalah contoh untuk menampilkan tabel yang berisi data ,dengan mengambil data yang sudah kita buat di microsoft excel. import pandas as pd from scipy import stats import numpy as np import seaborn as sns data = pd.read_csv(\"data.csv\") cm = sns.light_palette(\"white\", as_cmap=True) data.style.background_gradient(cmap=cm) Hasilnya Selanjutnya kita melakukan cara berikutnya , seperti dibawah ini colum = data.columns.tolist() for x in colum: ds=[x for x in data[x]] desc= data[x].describe() array= [x for x in desc] print(\"Detail kolom \",x) print(\"rata-rata: \",array[1]) print(\"Median: \",np.median(np.array(ds))) print(\"Modus: \", stats.mode(ds)) print(\"Standard deviasi: \",np.std(ds)) print(\"varian: \", stats.variation(ds)) print(\"Skewness: \",stats.skew(ds)) print(\"Quartil 1: \",array[4]) print(\"Quartil 2: \",array[5]) print(\"Quartil 3: \",array[6]) print(\"\\n\") \u200b Dan Hasilnya sebagai berikut : Detail kolom KOPI rata-rata: 105.416 Median: 106.0 Modus: ModeResult(mode=array([64]), count=array([11])) Standard deviasi: 27.12111620121856 varian: 0.25727703765290433 Skewness: -0.02099108069384586 Quartil 1: 80.0 Quartil 2: 106.0 Quartil 3: 130.0 Detail kolom ES TEH rata-rata: 106.532 Median: 108.0 Modus: ModeResult(mode=array([145]), count=array([13])) Standard deviasi: 26.43280113798006 varian: 0.24812076313201725 Skewness: -0.10272439817862315 Quartil 1: 84.0 Quartil 2: 108.0 Quartil 3: 129.0 Detail kolom ES DEGAN rata-rata: 102.992 Median: 102.0 Modus: ModeResult(mode=array([66]), count=array([11])) Standard deviasi: 26.35048265212613 varian: 0.25584980049058303 Skewness: 0.059224774215851296 Quartil 1: 78.75 Quartil 2: 102.0 Quartil 3: 125.0 Detail kolom ES KOPYOR rata-rata: 105.204 Median: 106.0 Modus: ModeResult(mode=array([131]), count=array([11])) Standard deviasi: 26.679325028943293 varian: 0.2535961087881002 Skewness: 0.003599489956518007 Quartil 1: 81.75 Quartil 2: 106.0 Quartil 3: 130.0","title":"Deskripsi"},{"location":"MengukurJarak/","text":"Mengukur Jarak Data Mengukur Jarak Numerik Salah satu tantangan dalam era ini dengan datatabase yang memiliki banyak tipe data. Mengukur jarak adalah komponen utama dalam algoritma clustering berbasis jarak. Alogritma seperit Algoritma Partisioning misal K-Mean, K-medoidm dan fuzzy c-mean dan rough clustering bergantung pada jarak untuk melakukan pengelompokkan Sebelum menjelaskan tentang beberapa macam ukuran jarak, kita mendefinisikan terlebih dahulu yaiut v1,v2 menyatakandua vektor yang menyatakan v1=x1,x2,...,xn,v2=y1,y2,...,yn, dimana xi,yi disebut attribut. Ada beberapa ukuran similaritas datau ukuran jarak, diantaranya Minkowski Distance kelompok Minkowski diantaranya adalah Euclidean distance dan Manhattan distance, yang menjadi kasus khusus dari Minkowski Distance.Minkowski Distance dinyatakan dengan $$ d _ { \\operatorname { min } } = ( \\ sum _ { i = 1 } ^ { n } | x _ { i } - y _ { i } | ^ { m } ) ^ { \\frac { 1 } { m } } , m \\geq 1 $$ Uuclidean Distance Jarak yang paling terkenal yang digunakan untuk data numerik adalah jarak Euclidean. Ini adalah kasus khusus dari jarak Minkowski ketika m = 2. Jarak Euclidean berkinerja baik ketika digunakan untuk kumpulan data cluster kompak atau terisolasi . Meskipun jarak Euclidean sangat umum dalam pengelompokan, ia memiliki kelemahan: jika dua vektor data tidak memiliki nilai atribut yang sama, kemungkin memiliki jarak yang lebih kecil daripada pasangan vektor data lainnya yang mengandung nilai atribut yang sama. Masalah lain dengan jarak Euclidean sebagai fitur skala terbesar akan mendominasi yang lain. Normalisasi fitur kontinu adalah solusi untuk mengatasi kelemahan ini Average Distance Berkenaan dengan kekurangan dari Jarak Euclidian Distance diatas, rata rata jarak adala versi modikfikasid ari jarak Euclidian untuk memperbaiki hasil. Untuk dua titik x,yx,y dalam ruang dimensi nn, rata-rata jarak didefinisikan dengan Average Distance $$ d _ { a v e } = \\left ( \\frac { 1 } { n } \\sum _ { i = 1 } ^ { n } ( x _ { i } - y _ { i } ) ^ { 2 } \\right) ^ { \\frac { 1 } { 2 } } $$ Manhattan distance Manhattan distance adalah kasus khsusu dari jarak Minkowski distance pada m = 1. Seperti Minkowski Distance, Manhattan distance sensitif terhadap outlier. BIla ukuran ini digunakan dalam algoritma clustering , bentuk cluster adalah hyper-rectangular. Ukuran ini didefinisikan dengan MathJax.Hub.Config({ tex2jax: {inlineMath:[['$$','$$']]} }); \u200b \u200b","title":"Mengukur Jarak"},{"location":"MengukurJarak/#mengukur-jarak-data","text":"","title":"Mengukur Jarak Data"},{"location":"MengukurJarak/#mengukur-jarak-numerik","text":"Salah satu tantangan dalam era ini dengan datatabase yang memiliki banyak tipe data. Mengukur jarak adalah komponen utama dalam algoritma clustering berbasis jarak. Alogritma seperit Algoritma Partisioning misal K-Mean, K-medoidm dan fuzzy c-mean dan rough clustering bergantung pada jarak untuk melakukan pengelompokkan Sebelum menjelaskan tentang beberapa macam ukuran jarak, kita mendefinisikan terlebih dahulu yaiut v1,v2 menyatakandua vektor yang menyatakan v1=x1,x2,...,xn,v2=y1,y2,...,yn, dimana xi,yi disebut attribut. Ada beberapa ukuran similaritas datau ukuran jarak, diantaranya","title":"Mengukur Jarak Numerik"},{"location":"MengukurJarak/#minkowski-distance","text":"kelompok Minkowski diantaranya adalah Euclidean distance dan Manhattan distance, yang menjadi kasus khusus dari Minkowski Distance.Minkowski Distance dinyatakan dengan $$ d _ { \\operatorname { min } } = ( \\ sum _ { i = 1 } ^ { n } | x _ { i } - y _ { i } | ^ { m } ) ^ { \\frac { 1 } { m } } , m \\geq 1 $$","title":"Minkowski Distance"},{"location":"MengukurJarak/#uuclidean-distance","text":"Jarak yang paling terkenal yang digunakan untuk data numerik adalah jarak Euclidean. Ini adalah kasus khusus dari jarak Minkowski ketika m = 2. Jarak Euclidean berkinerja baik ketika digunakan untuk kumpulan data cluster kompak atau terisolasi . Meskipun jarak Euclidean sangat umum dalam pengelompokan, ia memiliki kelemahan: jika dua vektor data tidak memiliki nilai atribut yang sama, kemungkin memiliki jarak yang lebih kecil daripada pasangan vektor data lainnya yang mengandung nilai atribut yang sama. Masalah lain dengan jarak Euclidean sebagai fitur skala terbesar akan mendominasi yang lain. Normalisasi fitur kontinu adalah solusi untuk mengatasi kelemahan ini","title":"Uuclidean Distance"},{"location":"MengukurJarak/#average-distance","text":"Berkenaan dengan kekurangan dari Jarak Euclidian Distance diatas, rata rata jarak adala versi modikfikasid ari jarak Euclidian untuk memperbaiki hasil. Untuk dua titik x,yx,y dalam ruang dimensi nn, rata-rata jarak didefinisikan dengan Average Distance $$ d _ { a v e } = \\left ( \\frac { 1 } { n } \\sum _ { i = 1 } ^ { n } ( x _ { i } - y _ { i } ) ^ { 2 } \\right) ^ { \\frac { 1 } { 2 } } $$","title":"Average Distance"},{"location":"MengukurJarak/#manhattan-distance","text":"Manhattan distance adalah kasus khsusu dari jarak Minkowski distance pada m = 1. Seperti Minkowski Distance, Manhattan distance sensitif terhadap outlier. BIla ukuran ini digunakan dalam algoritma clustering , bentuk cluster adalah hyper-rectangular. Ukuran ini didefinisikan dengan MathJax.Hub.Config({ tex2jax: {inlineMath:[['$$','$$']]} }); \u200b \u200b","title":"Manhattan distance"},{"location":"clustering/","text":"Clustering Categorical Data Clustering adalah sebuah proses untuk mengelompokan data ke dalam beberapa cluster atau kelompok sehingga data dalam satu cluster memiliki tingkat kemiripan yang maksimum dan data antar cluster memiliki kemiripan yang minimum. Metode K-Means Clustering K-Means adalah salah satu algoritma clustering / pengelompokan data yang bersifat Unsupervised Learning, yang berarti masukan dari algoritma ini menerima data tanpa label kelas. Fungsi dari algoritma ini adalah mengelompokkan data kedalam beberapa cluster. Karakteristik dari algoritma ini adalah : Memiliki n buah data Input berupa jumlah data dan jumlah cluster (kelompok) Pada setiap cluster / kelompok memiliki sebuah centroid yang mempresentasikan cluster tersebut. Algoritma K-Means Secara sederhana algoritma K-Means dimulai dari tahap berikut : Pilih K buah titik centroid. Menghitung jarak data dengan centroid. Update nilai titik centroid. Ulangi langkah 2 dan 3 sampai nilai dari titik centroid tidak lagi berubah. Rumus K-Means Metode K-Modes K-Modes merupakan pengembangan dari algoritma clustering K-means untuk menangani data kategorik di mana means diganti oleh modes. K-Modes menggunakan simple matching meassure dalam penentuan similarity dari suatu klaster. Rumus K-Modes Metode K-Prototype Tujuan dari simulasi ini adalah mencoba menerapkan algoritma K-Prototype pada data campuran numerik dan kategorikal. Ada tahap preparation diperlakukan terhadap data point numerik normalisasi terlebih dahulu. Rumus K-Prototype MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Clustering"},{"location":"clustering/#clustering-categorical-data","text":"Clustering adalah sebuah proses untuk mengelompokan data ke dalam beberapa cluster atau kelompok sehingga data dalam satu cluster memiliki tingkat kemiripan yang maksimum dan data antar cluster memiliki kemiripan yang minimum.","title":"Clustering Categorical Data"},{"location":"clustering/#metode-k-means-clustering","text":"K-Means adalah salah satu algoritma clustering / pengelompokan data yang bersifat Unsupervised Learning, yang berarti masukan dari algoritma ini menerima data tanpa label kelas. Fungsi dari algoritma ini adalah mengelompokkan data kedalam beberapa cluster. Karakteristik dari algoritma ini adalah : Memiliki n buah data Input berupa jumlah data dan jumlah cluster (kelompok) Pada setiap cluster / kelompok memiliki sebuah centroid yang mempresentasikan cluster tersebut.","title":"Metode K-Means Clustering"},{"location":"clustering/#algoritma-k-means","text":"Secara sederhana algoritma K-Means dimulai dari tahap berikut : Pilih K buah titik centroid. Menghitung jarak data dengan centroid. Update nilai titik centroid. Ulangi langkah 2 dan 3 sampai nilai dari titik centroid tidak lagi berubah.","title":"Algoritma K-Means"},{"location":"clustering/#rumus-k-means","text":"","title":"Rumus K-Means"},{"location":"clustering/#metode-k-modes","text":"K-Modes merupakan pengembangan dari algoritma clustering K-means untuk menangani data kategorik di mana means diganti oleh modes. K-Modes menggunakan simple matching meassure dalam penentuan similarity dari suatu klaster.","title":"Metode K-Modes"},{"location":"clustering/#rumus-k-modes","text":"","title":"Rumus K-Modes"},{"location":"clustering/#metode-k-prototype","text":"Tujuan dari simulasi ini adalah mencoba menerapkan algoritma K-Prototype pada data campuran numerik dan kategorikal. Ada tahap preparation diperlakukan terhadap data point numerik normalisasi terlebih dahulu.","title":"Metode K-Prototype"},{"location":"clustering/#rumus-k-prototype","text":"MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Rumus K-Prototype"},{"location":"decision tree/","text":"DECISION TREE dicision tree merupakan suatu prediksi yang di gambarkan dengan bentuk berupa pohon. CARA MEMBUAT DECISION TREE \u200b Ada beberapa cara membuat decision tree disini saya akan membuat dengan cara mengurutkan poperty yang paling penting.Dan kita harus mengetahui rumus rumusnya ,berikut adalah rumus-rumusnya ,silahkan disimak $$ Entropy(S)={\\sum \\limits_{i=1}^{n} -pi\\quad log_2\\quad pi} $$ keterangan: S=Himpunan kasus n = jumlah partisi S pi= proposi Si terhadap S kemudian hitung nilai gain menggunakan rumus : $$ GAIN(S,A)= entropy(S)-{\\sum \\limits_{i=1}^{n} \\frac{|Si|}{|s|}*entropy(Si)} $$ keterangan: S=himpunan kasus n=jumlah partisi S |si|=proporsi terhadap S |s|=jumlah kasus dalam S untuk mempermudah penghitungan saya menggunakan fungsi pembantu, seperti fungsi banyak_elemen untuk mengecek ada berapa elemen dalam sebuah kolom atau fiture/class. # menentukan value atau jenis pada atribut def banyak_elemen (kolom, data): kelas=[] for i in range (len(data)): if data.values.tolist()[i][kolom] not in kelas: kelas.append(data.values.tolist()[i][kolom]) return kelas kelas=banyak_elemen(df.shape[1]-1, df) outlook=banyak_elemen(df.shape[1]-5,df) temp=banyak_elemen(df.shape[1]-4,df) humidity=banyak_elemen(df.shape[1]-3,df) windy=banyak_elemen(df.shape[1]-2,df) print(kelas,outlook,temp,humidity,windy)` ['no', 'yes'] ['sunny', 'overcast', 'rainy'] ['hot', 'mild', 'cool'] ['high', 'normal'] [False, True] Fungsi countvKelas untuk menghitung berapa perbandingan setiap elemen yang terdapat di class. # menentukan count value pada Kelas def countvKelas(kelas,kolomKelas,data): hasil=[] for x in range(len(kelas)): hasil.append(0) for i in range (len(data)): for j in range (len(kelas)): if data.values.tolist()[i][kolomKelas] == kelas[j]: hasil[j]+=1 return hasil pKelas=countvKelas(kelas,df.shape[1]-1,df) pKelas [5, 9] Fungsi entropy untuk Menghitung nilai entropy pada sebuah fiture/class. fungsi e_list untuk mempermudah penghitungan entropy setiap elemen di dalam sebuah fiture. # menentukan nilai entropy target def entropy(T): hasil=0 jumlah=0 for y in T: jumlah+=y for z in range (len(T)): if jumlah!=0: T[z]=T[z]/jumlah for i in T: if i != 0: hasil-=i*math.log(i,2) return hasil def e_list(atribut,n): temp=[] tx=t_list(atribut,n) for i in range (len(atribut)): ent=entropy(tx[i]) temp.append(ent) return temp tOutlook=t_list(outlook,5) tTemp=t_list(temp,4) tHum=t_list(humidity,3) tWin=t_list(windy,2) print(\"Sunny, Overcast, Rainy\",eOutlook) print(\"Hot, Mild, Cold\", eTemp) print(\"High, Normal\", eHum) print(\"False, True\", eWin) Sunny, Overcast, Rainy [0.9709505944546686, 0.0, 0.9709505944546686] Hot, Mild, Cold [1.0, 0.9182958340544896, 0.8112781244591328] High, Normal [0.9852281360342516, 0.5916727785823275] False, True [0.8112781244591328, 1.0] contoh data yang dirubah jadi decision tree \u200b 0 1 2 3 4 0 CASTEMER ID GENDER CAR TIPE SHIRT SIZE CLASS 1 1 M FAMILY SMALL C0 2 2 M SPORT MEDIUM C0 3 3 M SPORT MEDIUM C0 4 4 M SPORT LARGE C0 5 5 M SPORT EXTRA LARGE C0 6 6 M SPORT EXTRA LARGE C0 7 7 F SPORT SMALL C0 8 8 F SPORT SMALL C0 9 9 F SPORT MEDIUM C1 10 10 F LUXURY LARGE C1 11 11 M FAMILY LARGE C1 12 12 M FAMILY EXTRA LARGE C1 13 13 M FAMILY MEDIUM C1 14 14 M LUCURY EXTRA LARGE C1 15 15 F LUCURY SMALL C1 16 16 F LUCURY SMALL C1 17 17 F LUCURY MEDIUM C1 18 18 F LUCURY MEDIUM C1 19 19 F LUCURY MEDIUM C1 20 20 F LUCURY LARGE C1 pertama mencari *entropy(s)* dari kolom class di atas Diketahui co=10 = Pi=10/20 c1=10=Pi=10/20 $$ Entropy(S)={\\sum \\limits_{i=1}^{n} -pi\\quad log2\\quad pi} $$ $$ Entropy(S)= -10/20 * log2 10/20 -10/20 *log2 10/20 $$ $$ Entropy(S)= 1 $$ lalu kita menghitung gain setiap kolom di atas: $$ GAIN(GENDER)= entropy(S)-{\\sum \\limits_{i=1}^{n} \\frac{|Si|}{|s|}*entropy(Si)} $$ GAIN(GENDER)= 1-[10/20(6,4)+10/20(4,6)] = 1-10/20(-6/10 x log2 6/10 - 4/10 x log2 4/10) +10/20(-4/10 x log2 4/10 - 6/10 x log2 6/10 ) =1-(10/20 x 0,970951)+(10/20 x 0,970951) =1-(0,4485475+0,4485475) =1-0,970951 =0.029049 $$ GAIN(CAR\\quad TIPE)= entropy(S)-{\\sum \\limits_{i=1}^{n} \\frac{|Si|}{|s|}*entropy(Si)} $$ GAIN(CAR TIPE)= 1-[4/20(1,3)+8/20(8,0)+8/20(1,7)] = 1-4/20(-1/4 x log2 1/4 - 3/4 x log2 3/4) +8/20(-8/8 x log2 8/8 - 0/8 x log2 0/8 )+8/20(-1/8 x log2 1/8 - 7/8 x log2 7/8) =1-(0,162256+0+0,217426) =1-0,379681 =0,620319 GAIN(shirt hat)= 1-[5/20(3,2)+7/20(3,4)+4/20(2,2)+4/20(2,2)] = 1-5/20(-3/5 x log2 3/5 - 2/5 x log2 2/45 +7/20(-3/7 x log2 3/7 - 4/7 x log2 4/7 )+4/20(-2/4 x log2 2/4 - 2/2 x log2 2/2)+4/20(-2/4 log2 2/4-2/4 log2 2/4) =1-(0,242738+0,34483+0,2+0,2) =1-0,987567 =0,012433 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]}});","title":"Decision tree"},{"location":"decision tree/#decision-tree","text":"dicision tree merupakan suatu prediksi yang di gambarkan dengan bentuk berupa pohon.","title":"DECISION TREE"},{"location":"decision tree/#cara-membuat-decision-tree","text":"\u200b Ada beberapa cara membuat decision tree disini saya akan membuat dengan cara mengurutkan poperty yang paling penting.Dan kita harus mengetahui rumus rumusnya ,berikut adalah rumus-rumusnya ,silahkan disimak $$ Entropy(S)={\\sum \\limits_{i=1}^{n} -pi\\quad log_2\\quad pi} $$ keterangan: S=Himpunan kasus n = jumlah partisi S pi= proposi Si terhadap S kemudian hitung nilai gain menggunakan rumus : $$ GAIN(S,A)= entropy(S)-{\\sum \\limits_{i=1}^{n} \\frac{|Si|}{|s|}*entropy(Si)} $$ keterangan: S=himpunan kasus n=jumlah partisi S |si|=proporsi terhadap S |s|=jumlah kasus dalam S untuk mempermudah penghitungan saya menggunakan fungsi pembantu, seperti fungsi banyak_elemen untuk mengecek ada berapa elemen dalam sebuah kolom atau fiture/class. # menentukan value atau jenis pada atribut def banyak_elemen (kolom, data): kelas=[] for i in range (len(data)): if data.values.tolist()[i][kolom] not in kelas: kelas.append(data.values.tolist()[i][kolom]) return kelas kelas=banyak_elemen(df.shape[1]-1, df) outlook=banyak_elemen(df.shape[1]-5,df) temp=banyak_elemen(df.shape[1]-4,df) humidity=banyak_elemen(df.shape[1]-3,df) windy=banyak_elemen(df.shape[1]-2,df) print(kelas,outlook,temp,humidity,windy)` ['no', 'yes'] ['sunny', 'overcast', 'rainy'] ['hot', 'mild', 'cool'] ['high', 'normal'] [False, True] Fungsi countvKelas untuk menghitung berapa perbandingan setiap elemen yang terdapat di class. # menentukan count value pada Kelas def countvKelas(kelas,kolomKelas,data): hasil=[] for x in range(len(kelas)): hasil.append(0) for i in range (len(data)): for j in range (len(kelas)): if data.values.tolist()[i][kolomKelas] == kelas[j]: hasil[j]+=1 return hasil pKelas=countvKelas(kelas,df.shape[1]-1,df) pKelas [5, 9] Fungsi entropy untuk Menghitung nilai entropy pada sebuah fiture/class. fungsi e_list untuk mempermudah penghitungan entropy setiap elemen di dalam sebuah fiture. # menentukan nilai entropy target def entropy(T): hasil=0 jumlah=0 for y in T: jumlah+=y for z in range (len(T)): if jumlah!=0: T[z]=T[z]/jumlah for i in T: if i != 0: hasil-=i*math.log(i,2) return hasil def e_list(atribut,n): temp=[] tx=t_list(atribut,n) for i in range (len(atribut)): ent=entropy(tx[i]) temp.append(ent) return temp tOutlook=t_list(outlook,5) tTemp=t_list(temp,4) tHum=t_list(humidity,3) tWin=t_list(windy,2) print(\"Sunny, Overcast, Rainy\",eOutlook) print(\"Hot, Mild, Cold\", eTemp) print(\"High, Normal\", eHum) print(\"False, True\", eWin) Sunny, Overcast, Rainy [0.9709505944546686, 0.0, 0.9709505944546686] Hot, Mild, Cold [1.0, 0.9182958340544896, 0.8112781244591328] High, Normal [0.9852281360342516, 0.5916727785823275] False, True [0.8112781244591328, 1.0] contoh data yang dirubah jadi decision tree \u200b 0 1 2 3 4 0 CASTEMER ID GENDER CAR TIPE SHIRT SIZE CLASS 1 1 M FAMILY SMALL C0 2 2 M SPORT MEDIUM C0 3 3 M SPORT MEDIUM C0 4 4 M SPORT LARGE C0 5 5 M SPORT EXTRA LARGE C0 6 6 M SPORT EXTRA LARGE C0 7 7 F SPORT SMALL C0 8 8 F SPORT SMALL C0 9 9 F SPORT MEDIUM C1 10 10 F LUXURY LARGE C1 11 11 M FAMILY LARGE C1 12 12 M FAMILY EXTRA LARGE C1 13 13 M FAMILY MEDIUM C1 14 14 M LUCURY EXTRA LARGE C1 15 15 F LUCURY SMALL C1 16 16 F LUCURY SMALL C1 17 17 F LUCURY MEDIUM C1 18 18 F LUCURY MEDIUM C1 19 19 F LUCURY MEDIUM C1 20 20 F LUCURY LARGE C1 pertama mencari *entropy(s)* dari kolom class di atas Diketahui co=10 = Pi=10/20 c1=10=Pi=10/20 $$ Entropy(S)={\\sum \\limits_{i=1}^{n} -pi\\quad log2\\quad pi} $$ $$ Entropy(S)= -10/20 * log2 10/20 -10/20 *log2 10/20 $$ $$ Entropy(S)= 1 $$ lalu kita menghitung gain setiap kolom di atas: $$ GAIN(GENDER)= entropy(S)-{\\sum \\limits_{i=1}^{n} \\frac{|Si|}{|s|}*entropy(Si)} $$ GAIN(GENDER)= 1-[10/20(6,4)+10/20(4,6)] = 1-10/20(-6/10 x log2 6/10 - 4/10 x log2 4/10) +10/20(-4/10 x log2 4/10 - 6/10 x log2 6/10 ) =1-(10/20 x 0,970951)+(10/20 x 0,970951) =1-(0,4485475+0,4485475) =1-0,970951 =0.029049 $$ GAIN(CAR\\quad TIPE)= entropy(S)-{\\sum \\limits_{i=1}^{n} \\frac{|Si|}{|s|}*entropy(Si)} $$ GAIN(CAR TIPE)= 1-[4/20(1,3)+8/20(8,0)+8/20(1,7)] = 1-4/20(-1/4 x log2 1/4 - 3/4 x log2 3/4) +8/20(-8/8 x log2 8/8 - 0/8 x log2 0/8 )+8/20(-1/8 x log2 1/8 - 7/8 x log2 7/8) =1-(0,162256+0+0,217426) =1-0,379681 =0,620319 GAIN(shirt hat)= 1-[5/20(3,2)+7/20(3,4)+4/20(2,2)+4/20(2,2)] = 1-5/20(-3/5 x log2 3/5 - 2/5 x log2 2/45 +7/20(-3/7 x log2 3/7 - 4/7 x log2 4/7 )+4/20(-2/4 x log2 2/4 - 2/2 x log2 2/2)+4/20(-2/4 log2 2/4-2/4 log2 2/4) =1-(0,242738+0,34483+0,2+0,2) =1-0,987567 =0,012433 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]}});","title":"CARA MEMBUAT DECISION TREE"},{"location":"missingvalue/","text":"Memperlakukan Missing Value Dengan Metode KNN Missing Value Missing value adalah informasi yang tidak tersedia untuk sebuah objek (kasus) K-Nearest Neighbor (KNN) Salah satu usaha untuk memperlakukan missing data yaitu dengan menggunakan Algoritma K-Nearest Neighbor (KNN). Lalu apa yang dimaksud dengan KNN? Algoritma K-Nearest Neighbor (K-NN) adalah sebuah metode klasifikasi terhadap sekumpulan data berdasarkan pembelajaran data yang sudah terklasifikasikan sebelumya. Termasuk dalam supervised learning , dimana hasil query instance yang baru diklasifikasikan berdasarkan mayoritas kedekatan jarak dari kategori yang ada dalam K-NN . Algroritma pada K-Nearest Neighbor (KNN) Langkah utama dalam metode KNN yaitu dengan menghitung nilai k. Nilai k yang dimaksud yaitu jarak tetangga terdekat antar dataset. Kemudian, hasil perhitungan nilai k tersebut menjadi nilai estimator yang digunakan untuk mengisi pada data yang hilang tersebut. Perhitungan untuk mencari nilai k yaitu tergantung dengan jenis data. Apabila data yang disajikan berupa data kontinu, maka menggunakan rata-rata dari tetangga terdekat. Dan apabila data yang disajikan berupa data kualitatif, maka diambil dari nilai yang sering keluar pada objek. Dapat dimisalkan bahwa D merupakan suatu objek yang memiliki kasus missing data. Dengan Dc merupakan subdata yang lengkap, sedangkan Dm merupakan sub data yang memiliki kerumpangan (mengandung atribut yang hilang). Maka, tahapan langkah algoritma pada KKN sebagai berikut : Menentukan parameter k (jumlah tetangga paling dekat). Menghitung kuadrat jarak eucliden objek terhadap data training yang diberikan. Mengurutkan hasil no 2 secara ascending (berurutan dari nilai tinggi ke rendah) Mengumpulkan kategori Y (Klasifikasi nearest neighbor berdasarkan nilai k) Dengan menggunakan kategori nearest neighbor yang paling mayoritas maka dapat dipredisikan kategori objek. # importing pandas as pd import pandas as pd # importing numpy as np import numpy as np # dictionary of lists dict = {'Score Pertama':[100, 80, np.nan, 65], 'Score Kedua': [80, 55, 76, np.nan], 'Score Ketiga':[np.nan, 60, 90, 87], 'Score Keempat':[np.nan, 50, 65,75]} # creating a dataframe from dictionary df = pd.DataFrame(dict) # filling missing value using fillna() df.fillna(0) Score Pertama Score Kedua Score Ketiga Score Keempat 0 100.0 80.0 60.0 75.0 1 80.0 55.0 60.0 65.0 2 0.0 76.0 90.0 0.0 3 65.0 0.0 87.0 60.0 4 75.0 0.0 77.0 50.0 MathJax.Hub.Config({ tex2jax: {inlineMath:[['$$','$$']]} }); \u200b","title":"Mencari Missing value"},{"location":"missingvalue/#memperlakukan-missing-value-dengan-metode-knn","text":"","title":"Memperlakukan Missing Value Dengan Metode  KNN"},{"location":"missingvalue/#missing-value","text":"Missing value adalah informasi yang tidak tersedia untuk sebuah objek (kasus)","title":"Missing Value"},{"location":"missingvalue/#k-nearest-neighbor-knn","text":"Salah satu usaha untuk memperlakukan missing data yaitu dengan menggunakan Algoritma K-Nearest Neighbor (KNN). Lalu apa yang dimaksud dengan KNN? Algoritma K-Nearest Neighbor (K-NN) adalah sebuah metode klasifikasi terhadap sekumpulan data berdasarkan pembelajaran data yang sudah terklasifikasikan sebelumya. Termasuk dalam supervised learning , dimana hasil query instance yang baru diklasifikasikan berdasarkan mayoritas kedekatan jarak dari kategori yang ada dalam K-NN .","title":"K-Nearest Neighbor (KNN)"},{"location":"missingvalue/#algroritma-pada-k-nearest-neighbor-knn","text":"Langkah utama dalam metode KNN yaitu dengan menghitung nilai k. Nilai k yang dimaksud yaitu jarak tetangga terdekat antar dataset. Kemudian, hasil perhitungan nilai k tersebut menjadi nilai estimator yang digunakan untuk mengisi pada data yang hilang tersebut. Perhitungan untuk mencari nilai k yaitu tergantung dengan jenis data. Apabila data yang disajikan berupa data kontinu, maka menggunakan rata-rata dari tetangga terdekat. Dan apabila data yang disajikan berupa data kualitatif, maka diambil dari nilai yang sering keluar pada objek. Dapat dimisalkan bahwa D merupakan suatu objek yang memiliki kasus missing data. Dengan Dc merupakan subdata yang lengkap, sedangkan Dm merupakan sub data yang memiliki kerumpangan (mengandung atribut yang hilang). Maka, tahapan langkah algoritma pada KKN sebagai berikut : Menentukan parameter k (jumlah tetangga paling dekat). Menghitung kuadrat jarak eucliden objek terhadap data training yang diberikan. Mengurutkan hasil no 2 secara ascending (berurutan dari nilai tinggi ke rendah) Mengumpulkan kategori Y (Klasifikasi nearest neighbor berdasarkan nilai k) Dengan menggunakan kategori nearest neighbor yang paling mayoritas maka dapat dipredisikan kategori objek. # importing pandas as pd import pandas as pd # importing numpy as np import numpy as np # dictionary of lists dict = {'Score Pertama':[100, 80, np.nan, 65], 'Score Kedua': [80, 55, 76, np.nan], 'Score Ketiga':[np.nan, 60, 90, 87], 'Score Keempat':[np.nan, 50, 65,75]} # creating a dataframe from dictionary df = pd.DataFrame(dict) # filling missing value using fillna() df.fillna(0) Score Pertama Score Kedua Score Ketiga Score Keempat 0 100.0 80.0 60.0 75.0 1 80.0 55.0 60.0 65.0 2 0.0 76.0 90.0 0.0 3 65.0 0.0 87.0 60.0 4 75.0 0.0 77.0 50.0 MathJax.Hub.Config({ tex2jax: {inlineMath:[['$$','$$']]} }); \u200b","title":"Algroritma pada K-Nearest Neighbor (KNN)"},{"location":"statistikdeskriptif/","text":"Statistik Deskriptif Pengertian Pengertian statistik deskriptif metode pengumpulan sebuah data data yang akan menghasilkan informasi yang berguna Tipe statistik deskriptif Mean(Rata-rata) Mean atau rata rata adalah sebuah nilai yang jumlah dari seluruah angka atau data dan di bagi banyak data .misal memiliki N data bisa di hitung dengan rumus sebagai berikut $$ \\begin{align} \\bar{X} = \\frac{1}{n} \\sum_{i=1}^n X_i={a_1+a_2+a_3+a_4+........+a_n \\over n} \\end{align} $$ keterangan: x=rata-rata a=nilai ke N n=banyak nilai atau data Median median merupakan nilai tengah dalam suatu data median disimbolkan Me .menghitung median mempunyai 2 metode yaitu ketika N atau jumlah data ganjil atau genap. berikut rumus median ; $$ Me=Q_2 =\\left( \\begin{matrix} n+1 \\over 2 \\end{matrix} \\right), jika\\quad n\\quad ganjil $$ $$ Me=Q_2 =\\left( \\begin{matrix} {xn \\over 2 } {xn+1\\over 2} \\over 2 \\end{matrix} \\right), jika\\quad n\\quad genap $$ keterangan: me =median atau nilai tengah n=banyak data Modus Modus adalah nilai yang sering muncul dalam himpunan data.brikut ini rumus mencari modus dalam himpunan data $$ M_o = Tb + p{b_1 \\over b_1 + b_2} $$ ket; mo=nilai modus tb= tepi bawah b1=selisih frekuensi antara nilai mudus dengan elemen sebelumnya b2=selisih frekuensi antara nilai mudus dengan elemen sesudahnya p= panjang interval Varian Varian adalah penyebaran nilai dalam suatu data dari rata rata .berikut ini rumus dari varian dalam himpunan data $$ \\sigma^2 = {\\sum \\limits_{i=1}^{n} (x_i - \\bar x)^2 \\over n} $$ Keterangan: x=rata rata Xi=rata rata dari semua titik data n= banyak dari anggota data \u200b Standart Deviasi Standar deviasi adalah ukuran kumpulan data relatif terhadap rata-rata atau akar kuadrat positif dari varian. $$ t {{\\sum \\limits_{i=1}^{n} (x_i - \\bar x)^2 \\over n}} $$ Skewness adalah ketidaksimetrisan pada suatu distribusi statistik dimana kurva tampak condong ke kiri atau ke kanan. Skewness bisa dihitung menggunakan rumus sebagai berikut: $$ {\\sum \\limits{i=1}^n (x_i - \\bar x)^i \\over (n- 1) \\sigma^3} $$ Quartile Quartile adalah irisan nilai dari hasil pembagian data menjadi empat bagian yang sama besar. $$ Q_1 = (n + 1) {1\\over 4} $$ $$ Q_2 = (n + 1) {1\\over 2} $$ $$ Q_3 = (n + 1) {3\\over 4} $$ Penerapan Pada Python Pada penerapan ini saya menggunakan 500 data random yang disimpan dalam bentuk .csv dan untuk mempermudah dalam penerapan tersebut, perlu disiapkan library python yang dapat didownload secara gratis. dalam kasus ini, library python yang digunakan adalah sebagai berikut: pandas, digunakan untuk data manajemen dan data analysis. scipy, merupakan library berisi kumpulan algoritma dan fungsi matematika. Pertama py import pandas as pd from scipy import stats Kedua py df = pd.read_csv('sample_data.csv', sep=';') Ketiga py data = {\"Stats\" : ['Min','Max','Mean','Standard Deviasi','Variasi','Skewnes', 'Quartile 1','Quartile 2', 'Quartile 3', 'Median','Modus']} for i in df.columns: data[i] = [df[i].min(), df[i].max(), df[i].mean(), round(df[i].std(), 2),round(df[i].var(), 2), round(df[i].skew(), 2), df[i].quantile(0.25), df[i].quantile(0.5), df[i].quantile(0.75), df[i].median(), stats.mode(df[i]).mode[0]] import pandas as pd from scipy import stats df = pd.read_csv('wildan.csv',sep=';') data={\"stats\":['Min','Max','Mean','Standart Deviasi','Variasi','Skewnes','Quantile 1','Quantile 2', 'Quantile 3','Median','Modus']} for i in df.columns: data[i] = [df[i].min(), df[i].max(), df[i].mean(), round(df[i].std(),2), round(df[i].var(),2), round(df[i].skew(),2), df[i].quantile(0.25),df[i].quantile(0.5),df[i].quantile(0.75), df[i].median(), stats.mode(df[i]).mode[0]] tes = pd.DataFrame(data) tes.style.hide_index() stats ukuran baju ukuran sepatu ukaran celana umur Min 18 27 22 20 Max 30 42 36 40 Mean 23.76 34.452 28.812 29.828 Standart Deviasi 3.75 4.64 4.23 6.18 Variasi 14.05 21.53 17.93 38.18 Skewnes 0.08 0.02 0.08 -0 Quantile 1 21 30.75 25 24 Quantile 2 24 34 29 30 Quantile 3 27 39 32 35 Median 24 34 29 30 Modus 21 32 26 24 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Statistik Deskriptif"},{"location":"statistikdeskriptif/#statistik-deskriptif","text":"","title":"Statistik Deskriptif"},{"location":"statistikdeskriptif/#pengertian","text":"Pengertian statistik deskriptif metode pengumpulan sebuah data data yang akan menghasilkan informasi yang berguna","title":"Pengertian"},{"location":"statistikdeskriptif/#tipe-statistik-deskriptif","text":"Mean(Rata-rata) Mean atau rata rata adalah sebuah nilai yang jumlah dari seluruah angka atau data dan di bagi banyak data .misal memiliki N data bisa di hitung dengan rumus sebagai berikut $$ \\begin{align} \\bar{X} = \\frac{1}{n} \\sum_{i=1}^n X_i={a_1+a_2+a_3+a_4+........+a_n \\over n} \\end{align} $$ keterangan: x=rata-rata a=nilai ke N n=banyak nilai atau data Median median merupakan nilai tengah dalam suatu data median disimbolkan Me .menghitung median mempunyai 2 metode yaitu ketika N atau jumlah data ganjil atau genap. berikut rumus median ; $$ Me=Q_2 =\\left( \\begin{matrix} n+1 \\over 2 \\end{matrix} \\right), jika\\quad n\\quad ganjil $$ $$ Me=Q_2 =\\left( \\begin{matrix} {xn \\over 2 } {xn+1\\over 2} \\over 2 \\end{matrix} \\right), jika\\quad n\\quad genap $$ keterangan: me =median atau nilai tengah n=banyak data","title":"Tipe statistik deskriptif"},{"location":"statistikdeskriptif/#modus","text":"Modus adalah nilai yang sering muncul dalam himpunan data.brikut ini rumus mencari modus dalam himpunan data $$ M_o = Tb + p{b_1 \\over b_1 + b_2} $$ ket; mo=nilai modus tb= tepi bawah b1=selisih frekuensi antara nilai mudus dengan elemen sebelumnya b2=selisih frekuensi antara nilai mudus dengan elemen sesudahnya p= panjang interval","title":"Modus"},{"location":"statistikdeskriptif/#varian","text":"Varian adalah penyebaran nilai dalam suatu data dari rata rata .berikut ini rumus dari varian dalam himpunan data $$ \\sigma^2 = {\\sum \\limits_{i=1}^{n} (x_i - \\bar x)^2 \\over n} $$ Keterangan: x=rata rata Xi=rata rata dari semua titik data n= banyak dari anggota data \u200b","title":"Varian"},{"location":"statistikdeskriptif/#standart-deviasi","text":"Standar deviasi adalah ukuran kumpulan data relatif terhadap rata-rata atau akar kuadrat positif dari varian. $$ t {{\\sum \\limits_{i=1}^{n} (x_i - \\bar x)^2 \\over n}} $$","title":"Standart Deviasi"},{"location":"statistikdeskriptif/#skewness","text":"adalah ketidaksimetrisan pada suatu distribusi statistik dimana kurva tampak condong ke kiri atau ke kanan. Skewness bisa dihitung menggunakan rumus sebagai berikut: $$ {\\sum \\limits{i=1}^n (x_i - \\bar x)^i \\over (n- 1) \\sigma^3} $$","title":"Skewness"},{"location":"statistikdeskriptif/#quartile","text":"Quartile adalah irisan nilai dari hasil pembagian data menjadi empat bagian yang sama besar. $$ Q_1 = (n + 1) {1\\over 4} $$ $$ Q_2 = (n + 1) {1\\over 2} $$ $$ Q_3 = (n + 1) {3\\over 4} $$","title":"Quartile"},{"location":"statistikdeskriptif/#penerapan-pada-python","text":"Pada penerapan ini saya menggunakan 500 data random yang disimpan dalam bentuk .csv dan untuk mempermudah dalam penerapan tersebut, perlu disiapkan library python yang dapat didownload secara gratis. dalam kasus ini, library python yang digunakan adalah sebagai berikut: pandas, digunakan untuk data manajemen dan data analysis. scipy, merupakan library berisi kumpulan algoritma dan fungsi matematika. Pertama py import pandas as pd from scipy import stats Kedua py df = pd.read_csv('sample_data.csv', sep=';') Ketiga py data = {\"Stats\" : ['Min','Max','Mean','Standard Deviasi','Variasi','Skewnes', 'Quartile 1','Quartile 2', 'Quartile 3', 'Median','Modus']} for i in df.columns: data[i] = [df[i].min(), df[i].max(), df[i].mean(), round(df[i].std(), 2),round(df[i].var(), 2), round(df[i].skew(), 2), df[i].quantile(0.25), df[i].quantile(0.5), df[i].quantile(0.75), df[i].median(), stats.mode(df[i]).mode[0]] import pandas as pd from scipy import stats df = pd.read_csv('wildan.csv',sep=';') data={\"stats\":['Min','Max','Mean','Standart Deviasi','Variasi','Skewnes','Quantile 1','Quantile 2', 'Quantile 3','Median','Modus']} for i in df.columns: data[i] = [df[i].min(), df[i].max(), df[i].mean(), round(df[i].std(),2), round(df[i].var(),2), round(df[i].skew(),2), df[i].quantile(0.25),df[i].quantile(0.5),df[i].quantile(0.75), df[i].median(), stats.mode(df[i]).mode[0]] tes = pd.DataFrame(data) tes.style.hide_index() stats ukuran baju ukuran sepatu ukaran celana umur Min 18 27 22 20 Max 30 42 36 40 Mean 23.76 34.452 28.812 29.828 Standart Deviasi 3.75 4.64 4.23 6.18 Variasi 14.05 21.53 17.93 38.18 Skewnes 0.08 0.02 0.08 -0 Quantile 1 21 30.75 25 24 Quantile 2 24 34 29 30 Quantile 3 27 39 32 35 Median 24 34 29 30 Modus 21 32 26 24 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Penerapan Pada Python"}]}